{"title":"Cocos 热更新简介、原理、流程、案例","date":"2022-05-23T13:03:16.000Z","date_formatted":{"ll":"2022年5月23日","L":"2022/05/23","MM-DD":"05-23"},"thumbnail":"https://s1.ax1x.com/2022/03/14/bL6CLQ.md.png","link":"2022/05/23/Ca1AaW7p1PQIV0tF","comments":true,"tags":["CoCosCreator"],"categories":["CoCosCreator"],"updated":"2022-05-25T07:55:30.919Z","content":"<blockquote>\n<p>Cocos 热更新介绍</p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"简介：\">简介：<a title=\"#简介：\" href=\"#简介：\"></a></h1>\n<p>资源热更新是为游戏运行时动态更新资源而设计的，这里的资源可以是图片，音频甚至游戏逻辑。在游戏漫长的运营维护过程中，你将可以上传新的资源到你的服务器，让你的游戏跟踪远程服务器上的修改，自动下载新的资源到用户的设备上。就这样，全新的设计，新的游玩体验甚至全新的游戏内容都将立刻被推送到你的用户手上。重要的是，你不需要针对各个渠道去重新打包你的应用并经历痛苦的应用更新审核！</p>\n<h1 id=\"原理：\">原理：<a title=\"#原理：\" href=\"#原理：\"></a></h1>\n<p>热更新机制本质上是从服务器下载需要的资源到本地，并且可以执行新的游戏逻辑，让新资源可以被游戏所使用。<br>\n       Cocos 默认的热更新机制并不是基于补丁包更新的机制，传统的热更新经常对多个版本之间分别生成补丁包，按顺序下载补丁包并更新到最新版本。Cocos 的热更新机制通过直接比较最新版本和本地版本的差异来生成差异列表并更新。这样即可天然支持跨版本更新，比如本地版本为 A，远程版本是 C，则直接更新 A 和 C 之间的差异，并不需要生成 A 到 B 和 B 到 C 的更新包，依次更新。所以，在这种设计思路下，新版本的文件以离散的方式保存在服务端，更新时以文件为单位下载。</p>\n<h1 id=\"热更新基本流程：\">热更新基本流程：<a title=\"#热更新基本流程：\" href=\"#热更新基本流程：\"></a></h1>\n<p><img src=\"https://s1.ax1x.com/2022/05/24/XC8EU1.png\" alt=\"bWKCWV.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h1 id=\"包内资源、本地缓存资源和临时资源：\">包内资源、本地缓存资源和临时资源：<a title=\"#包内资源、本地缓存资源和临时资源：\" href=\"#包内资源、本地缓存资源和临时资源：\"></a></h1>\n<p>在开发者的游戏安装到用户的手机上时，它的游戏是以 .ipa（iOS）或者 .apk（Android）形式存在的，这种应用包在安装后，它的内容是无法被修改或者添加的，应用包内的任何资源都会一直存在。所以热更新机制中，我们只能更新本地缓存到手机的可写目录下（应用存储空间或者 SD 卡指定目录），并通过 FileUtils 的搜索路径机制完成本地缓存对包内资源的覆盖。同时为了保障更新的可靠性，我们在更新过程中会首先将新版本资源放到一个临时文件夹中，只有当本次更新正常完成，才会替换到本地缓存文件夹内。如果中途中断更新或者更新失败，此时的失败版本都不会污染现有的本地缓存。<br>\n<strong>注意：大版本的更新的情况下（1.0.4-&gt;1.0.5），记得把临时文件夹清空（确保大版本的包体里面所带的manifest文件为最新，否则会用回之前热更新manifes文件）。</strong></p>\n<h1 id=\"断点续传:\">断点续传:<a title=\"#断点续传:\" href=\"#断点续传:\"></a></h1>\n<p>在中断之后，再次启动热更新流程时，会去检查临时文件夹中是否有未完成的更新，校验版本是否和远程匹配后，则直接使用临时文件夹中的 Manifest 作为 Remote Manifest 继续更新。此时，对于下载状态为已完成的，不会重新下载，对于下载中的文件，会尝试发送续传请求给服务器（服务器需要支持 Accept-Ranges，否则从头开始下载）。</p>\n<h1 id=\"manifest-格式：\">Manifest 格式：<a title=\"#manifest-格式：\" href=\"#manifest-格式：\"></a></h1>\n<p>Manifest 格式是我们用来比较本地和远程资源差异的一种 json 格式，其中保存了主版本信息、引擎版本信息、资源列表及资源信息等：<br>\n{<br>\n“packageUrl” :          远程资源的本地缓存根路径<br>\n“remoteVersionUrl” :    [可选项] 远程版本文件的路径，用来判断服务器端是否有新版本的资源<br>\n“remoteManifestUrl” :   远程资源 Manifest 文件的路径，包含版本信息以及所有资源信息<br>\n“version” :             资源的版本<br>\n“engineVersion” :       引擎版本<br>\n“assets” :              所有资源列表<br>\n“key” :             资源的相对路径（相对于资源根目录）<br>\n“md5” :             md5 值代表资源文件的版本信息<br>\n“compressed” :      [可选项] 如果值为 true，文件被下载后会自动被解压，目前仅支持 zip 压缩格式<br>\n“size” :            [可选项] 文件的字节尺寸，用于快速获取进度信息<br>\n“searchPaths” :         需要添加到 FileUtils 中的搜索路径列表<br>\n}<br>\n主要我们用到的是：version.manifest和project.manifest<br>\nversion.manifest:用来做版本对比<br>\nproject.manifest：下载链接和文件类型及数据</p>\n<h1 id=\"控制并发：\">控制并发：<a title=\"#控制并发：\" href=\"#控制并发：\"></a></h1>\n<p>Cocos Creator v1.4 和 Cocos2d-x v3.15 开始，热更新管理器添加了控制下载并发数量的 API，使用方式如下：<br>\nassetsManager.setMaxConcurrentTask(10);</p>\n","prev":{"title":"JS number 精度丢失问题","link":"2022/05/25/Wsj4BSG3DcmlUTlE"},"plink":"https://skyFlya.github.io/2022/05/23/Ca1AaW7p1PQIV0tF/","toc":[{"id":"简介：","title":"简介：","index":"1"},{"id":"原理：","title":"原理：","index":"2"},{"id":"热更新基本流程：","title":"热更新基本流程：","index":"3"},{"id":"包内资源、本地缓存资源和临时资源：","title":"包内资源、本地缓存资源和临时资源：","index":"4"},{"id":"断点续传:","title":"断点续传:","index":"5"},{"id":"manifest-格式：","title":"Manifest 格式：","index":"6"},{"id":"控制并发：","title":"控制并发：","index":"7"}],"reward":true,"copyright":{"custom":"Copyright:自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0）"}}